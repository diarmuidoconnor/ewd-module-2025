## Simple EC2 stack.

Note, you only need to complete this section if the traditional stack resulted in a 504 Bad Gateway error. If you did not get the error, then skip to the next section. 

 To satisfy our desire to get a CDK stack working before progressing, we will adopt a simpler infrastructure architecture: a standalone EC2 instance with a Web server installed and a security group that allows HTTP access.

Destroy the current (faulty) stack:
```bash
$ cdk destroy
```
Replace the code in `lib/cdk-stack.ts` with the following:
~~~
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as ec2 from "aws-cdk-lib/aws-ec2";

export class CdkStack extends cdk.Stack {
 constructor(scope: Construct, id: string, props?: cdk.StackProps) {
 super(scope, id, props);

 const defaultVpc = ec2.Vpc.fromLookup(this, "VPC", { isDefault: true });
    
 const userData = ec2.UserData.forLinux();
 userData.addCommands(
 'sudo su',
 'yum install -y httpd',
 'systemctl start httpd',
 'systemctl enable httpd',
 'echo "<h1>Hello World from $(hostname -f)</h1>" > /var/www/html/index.html',
 );

 const serverSG = new ec2.SecurityGroup(this, "webserver-sg", {
 vpc: defaultVpc,
 allowAllOutbound: true,
 });
    
 serverSG.addIngressRule(
 ec2.Peer.anyIpv4(),
 ec2.Port.tcp(80),
 "allow HTTP access from anywhere"
 );
    
 const ec2Instance = new ec2.Instance(this, "ec2-instance", {
 vpc: defaultVpc,
 securityGroup: serverSG,
 instanceType: ec2.InstanceType.of(
 ec2.InstanceClass.BURSTABLE2,
 ec2.InstanceSize.MICRO
 ),
 machineImage: new ec2.AmazonLinuxImage({
 generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,
 }),
 userData
 });

 new cdk.CfnOutput(this, 'EC2 Public DNS', {
 value: ec2Instance.instancePublicDnsName ,
 });
 }
}
~~~

Deploy this new stack:
```bash
$ cdk deploy
```

The terminal response shows the DNS name for the EC2 instance. Copy this into a browser tab:

![][alternative]

The response confirms that the web server running on the EC2 instance is up and running.


### Infrastructure State Management.

In the management console, go to the EC2 console and click 'Security Groups' on the left panel. In the list of groups displayed, find the group with 'cdk-stack-webserversg' in its name. This security group currently has one inbound rule defined.

![][secgrp]

To demonstrate the state management feature of the CDK framework (and, by implication, CloudFormation's support for state management), in VS Code, open the file `lib/cdk-stack.ts` and uncomment the lines:

```ts
serverSG.addIngressRule(
 Peer.anyIpv4(),
 Port.tcp(22),
  "allow SSH access from anywhere"
);
```

This code adds a second rule to the security group of the server (EC2 instances). Now update the stack's state by redeploying the app using the same command:

```bash
$ cdk deploy
```

[Include the --profile option if relevant.]

Type y to allow CloudFormation to apply the changes to your deployed resources.

When the deployment is complete, recheck the security group in the AWS management console to confirm the **state change** has occurred:

![][secgrp2]

Change the same lines of code back to comments, then rerun the deploy command. CloudFormation will update the state by removing the rule from the inbound list.

[schema]: ./img/schema.png
[alb]: ./img/alb.png
[root]: ./img/root.png
[api]: ./img/api.png
[cf]: ./img/cf.png
[secgrp]: ./img/secgrp.png
[secgrp2]: ./img/secgrp2.png
[albmc]: ./img/albmc.png
[ec2]: ./img/ec2.png
[alternative]: ./img/alternative.png
